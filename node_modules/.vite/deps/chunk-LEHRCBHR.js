import {
  $e,
  B2 as B,
  Be,
  C2 as C,
  Fe,
  He,
  InterpreterStatus,
  J,
  Je,
  N2 as N,
  Qe,
  State,
  Tr,
  V2 as V,
  We,
  X2 as X,
  Xe,
  Ye,
  Z,
  Ze,
  ar,
  cr,
  ee,
  er,
  interpret,
  ir,
  j,
  jwtDecode,
  kr,
  lr,
  nr,
  or,
  qe,
  rr,
  sr,
  toObserver,
  tr,
  ur,
  wr,
  y,
  ze
} from "./chunk-R4GJFA2D.js";
import {
  require_react
} from "./chunk-OU5AQDZK.js";
import {
  __commonJS,
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    (function() {
      function is(x, y3) {
        return x === y3 && (0 !== x || 1 / x === 1 / y3) || x !== x && y3 !== y3;
      }
      function useSyncExternalStore$2(subscribe, getSnapshot) {
        didWarnOld18Alpha || void 0 === React3.startTransition || (didWarnOld18Alpha = true, console.error(
          "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
        ));
        var value = getSnapshot();
        if (!didWarnUncachedGetSnapshot) {
          var cachedValue = getSnapshot();
          objectIs(value, cachedValue) || (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ), didWarnUncachedGetSnapshot = true);
        }
        cachedValue = useState2({
          inst: { value, getSnapshot }
        });
        var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
        useLayoutEffect2(
          function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          },
          [subscribe, value, getSnapshot]
        );
        useEffect3(
          function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            return subscribe(function() {
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            });
          },
          [subscribe]
        );
        useDebugValue(value);
        return value;
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe, getSnapshot) {
        return getSnapshot();
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React3 = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is, useState2 = React3.useState, useEffect3 = React3.useEffect, useLayoutEffect2 = React3.useLayoutEffect, useDebugValue = React3.useDebugValue, didWarnOld18Alpha = false, didWarnUncachedGetSnapshot = false, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
      exports.useSyncExternalStore = void 0 !== React3.useSyncExternalStore ? React3.useSyncExternalStore : shim;
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
var require_with_selector_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports) {
    "use strict";
    (function() {
      function is(x, y3) {
        return x === y3 && (0 !== x || 1 / x === 1 / y3) || x !== x && y3 !== y3;
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React3 = require_react(), shim = require_shim(), objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore = shim.useSyncExternalStore, useRef4 = React3.useRef, useEffect3 = React3.useEffect, useMemo = React3.useMemo, useDebugValue = React3.useDebugValue;
      exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
        var instRef = useRef4(null);
        if (null === instRef.current) {
          var inst = { hasValue: false, value: null };
          instRef.current = inst;
        } else inst = instRef.current;
        instRef = useMemo(
          function() {
            function memoizedSelector(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                nextSnapshot = selector(nextSnapshot);
                if (void 0 !== isEqual && inst.hasValue) {
                  var currentSelection = inst.value;
                  if (isEqual(currentSelection, nextSnapshot))
                    return memoizedSelection = currentSelection;
                }
                return memoizedSelection = nextSnapshot;
              }
              currentSelection = memoizedSelection;
              if (objectIs(memoizedSnapshot, nextSnapshot))
                return currentSelection;
              var nextSelection = selector(nextSnapshot);
              if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
                return memoizedSnapshot = nextSnapshot, currentSelection;
              memoizedSnapshot = nextSnapshot;
              return memoizedSelection = nextSelection;
            }
            var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
              function() {
                return memoizedSelector(getSnapshot());
              },
              null === maybeGetServerSnapshot ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              }
            ];
          },
          [getSnapshot, getServerSnapshot, selector, isEqual]
        );
        var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
        useEffect3(
          function() {
            inst.hasValue = true;
            inst.value = value;
          },
          [value]
        );
        useDebugValue(value);
        return value;
      };
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/use-sync-external-store/shim/with-selector.js
var require_with_selector = __commonJS({
  "node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_with_selector_development();
    }
  }
});

// node_modules/@nhost/react/dist/index.esm.js
var import_react6 = __toESM(require_react());

// node_modules/@xstate/react/es/useMachine.js
var import_react3 = __toESM(require_react());
var import_with_selector = __toESM(require_with_selector());

// node_modules/@xstate/react/es/useInterpret.js
var import_react2 = __toESM(require_react());

// node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js
var import_react = __toESM(require_react());
var index = import_react.useLayoutEffect;

// node_modules/@xstate/react/es/useConstant.js
var React = __toESM(require_react());
function useConstant(fn) {
  var ref = React.useRef();
  if (!ref.current) {
    ref.current = { v: fn() };
  }
  return ref.current.v;
}

// node_modules/@xstate/react/es/useInterpret.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2))
        t[p2] = s[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __rest = function(s, e) {
  var t = {};
  for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
    t[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t[p2[i]] = s[p2[i]];
    }
  return t;
};
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar2 = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar2.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar2;
};
function useIdleInterpreter(getMachine, options) {
  var machine = useConstant(function() {
    return typeof getMachine === "function" ? getMachine() : getMachine;
  });
  if (typeof getMachine !== "function") {
    var _a = __read((0, import_react2.useState)(machine), 1), initialMachine = _a[0];
    if (getMachine !== initialMachine) {
      console.warn("Machine given to `useMachine` has changed between renders. This is not supported and might lead to unexpected results.\nPlease make sure that you pass the same Machine as argument each time.");
    }
  }
  var context = options.context, guards = options.guards, actions = options.actions, activities = options.activities, services = options.services, delays = options.delays, rehydratedState = options.state, interpreterOptions = __rest(options, ["context", "guards", "actions", "activities", "services", "delays", "state"]);
  var service = useConstant(function() {
    var machineConfig = {
      context,
      guards,
      actions,
      activities,
      services,
      delays
    };
    var machineWithConfig = machine.withConfig(machineConfig, function() {
      return __assign(__assign({}, machine.context), context);
    });
    return interpret(machineWithConfig, interpreterOptions);
  });
  index(function() {
    Object.assign(service.machine.options.actions, actions);
    Object.assign(service.machine.options.guards, guards);
    Object.assign(service.machine.options.activities, activities);
    Object.assign(service.machine.options.services, services);
    Object.assign(service.machine.options.delays, delays);
  }, [actions, guards, activities, services, delays]);
  return service;
}
function useInterpret(getMachine) {
  var _a = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    _a[_i - 1] = arguments[_i];
  }
  var _b = __read(_a, 2), _c = _b[0], options = _c === void 0 ? {} : _c, observerOrListener = _b[1];
  var service = useIdleInterpreter(getMachine, options);
  (0, import_react2.useEffect)(function() {
    if (!observerOrListener) {
      return;
    }
    var sub = service.subscribe(toObserver(observerOrListener));
    return function() {
      sub.unsubscribe();
    };
  }, [observerOrListener]);
  (0, import_react2.useEffect)(function() {
    var rehydratedState = options.state;
    service.start(rehydratedState ? State.create(rehydratedState) : void 0);
    return function() {
      service.stop();
      service.status = InterpreterStatus.NotStarted;
    };
  }, []);
  return service;
}

// node_modules/@xstate/react/es/utils.js
function getServiceSnapshot(service) {
  return service.status !== 0 ? service.getSnapshot() : service.machine.initialState;
}
function isService(actor) {
  return "state" in actor && "machine" in actor;
}

// node_modules/@xstate/react/es/useActor.js
var import_react4 = __toESM(require_react());
var import_with_selector2 = __toESM(require_with_selector());
function isActorWithState(actorRef) {
  return "state" in actorRef;
}

// node_modules/@xstate/react/es/useSelector.js
var import_react5 = __toESM(require_react());
var import_with_selector3 = __toESM(require_with_selector());
var defaultCompare = function(a, b) {
  return a === b;
};
var defaultGetSnapshot = function(a, initialStateCacheRef) {
  if (isService(a)) {
    if (a.status === 0 && initialStateCacheRef.current) {
      return initialStateCacheRef.current;
    }
    var snapshot = getServiceSnapshot(a);
    initialStateCacheRef.current = a.status === 0 ? snapshot : null;
    return snapshot;
  }
  return isActorWithState(a) ? a.state : void 0;
};
function useSelector(actor, selector, compare, getSnapshot) {
  if (compare === void 0) {
    compare = defaultCompare;
  }
  var initialStateCacheRef = (0, import_react5.useRef)(null);
  var subscribe = (0, import_react5.useCallback)(function(handleStoreChange) {
    var unsubscribe = actor.subscribe(handleStoreChange).unsubscribe;
    return unsubscribe;
  }, [actor]);
  var boundGetSnapshot = (0, import_react5.useCallback)(function() {
    if (getSnapshot) {
      return getSnapshot(actor);
    }
    return defaultGetSnapshot(actor, initialStateCacheRef);
  }, [actor, getSnapshot]);
  var selectedSnapshot = (0, import_with_selector3.useSyncExternalStoreWithSelector)(subscribe, boundGetSnapshot, boundGetSnapshot, selector, compare);
  return selectedSnapshot;
}

// node_modules/@xstate/react/es/createActorContext.js
var React2 = __toESM(require_react());

// node_modules/@nhost/react/dist/index.esm.js
var pe = C;
var Oe = class extends pe {
  constructor(t) {
    super({ ...t, start: false });
  }
};
var I = (0, import_react6.createContext)({});
var ve = ({
  nhost: e,
  initial: t,
  ...c
}) => {
  const i = useInterpret(e.auth.client.machine, { devTools: e.devTools });
  e.auth.client.start({ interpreter: i, initialSession: t, devTools: e.devTools });
  const h = (0, import_react6.useRef)(true);
  return (0, import_react6.useEffect)(() => {
    h.current ? h.current = false : t && i.send("SESSION_UPDATE", { data: { session: t } });
  }, [t, i]), import_react6.default.createElement(I.Provider, { value: e }, c.children);
};
var we = ve;
var f = () => {
  var c;
  const t = (c = (0, import_react6.useContext)(I).auth) == null ? void 0 : c.client.interpreter;
  if (!t)
    throw Error("Could not find the Nhost auth client. Did you wrap your app in <NhostProvider />?");
  return t;
};
var A = () => {
  const e = f();
  return useSelector(
    e,
    (t) => ({
      isAuthenticated: t.matches({ authentication: "signedIn" }),
      isLoading: t.hasTag("loading"),
      error: t.context.errors.authentication || null,
      isError: t.matches({ authentication: { signedOut: "failed" } }),
      connectionAttempts: t.context.importTokenAttempts
    }),
    (t, c) => t.isAuthenticated === c.isAuthenticated && t.isLoading === c.isLoading && t.connectionAttempts === c.connectionAttempts
  );
};
function Ae({ children: e }) {
  const { isAuthenticated: t } = A();
  return t ? (0, import_react6.createElement)(import_react6.Fragment, null, e) : null;
}
function Ue({ children: e }) {
  const { isAuthenticated: t } = A();
  return t ? null : (0, import_react6.createElement)(import_react6.Fragment, null, e);
}
var U = () => {
  const e = f();
  return useSelector(e, (t) => t.context.accessToken.value);
};
var p = () => (0, import_react6.useContext)(I);
var Le = () => {
  const e = p(), [t, c] = (0, import_react6.useState)(null), i = !t, h = !!t, [l, m] = (0, import_react6.useState)(false);
  return { add: async (a) => {
    m(true);
    const s = await qe(e.auth.client, a), { error: o } = s;
    return o && c(o), m(false), s;
  }, isLoading: l, isSuccess: i, isError: h, error: t };
};
var Ce = () => {
  const e = f(), [t, c] = (0, import_react6.useState)(
    !!e.status && e.getSnapshot().matches({ authentication: "signedIn" })
  );
  return (0, import_react6.useEffect)(() => e.subscribe((h) => {
    const l = h.matches({ authentication: "signedIn" });
    c(l);
  }).unsubscribe, [e]), t;
};
function Me(e) {
  const t = p(), c = (0, import_react6.useMemo)(() => $e(t.auth.client), [t]), i = useInterpret(c), h = useSelector(i, (s) => s.matches("requesting")), l = useSelector(i, (s) => s.context.error), m = useSelector(i, (s) => s.matches("idle.error")), g = useSelector(i, (s) => s.matches("idle.success"));
  return { changeEmail: (0, import_react6.useCallback)(
    async (s, o = e) => Fe(i, s, o),
    [i, e]
  ), isLoading: h, needsEmailVerification: g, isError: m, error: l };
}
var Ne = () => {
  const e = p(), t = (0, import_react6.useMemo)(() => We(e.auth.client), [e]), c = useInterpret(t), i = useSelector(c, (a) => a.matches({ idle: "error" })), h = useSelector(c, (a) => a.matches({ idle: "success" })), l = useSelector(c, (a) => a.context.error), m = useSelector(c, (a) => a.matches("requesting"));
  return { changePassword: (a) => Be(c, a), isLoading: m, isSuccess: h, isError: i, error: l };
};
var Re = () => {
  const e = p(), t = (0, import_react6.useMemo)(() => Tr(e.auth.client), [e]), c = useInterpret(t), i = useSelector(
    c,
    (d) => d.matches({ idle: "error" }) || d.matches({ generated: { idle: "error" } })
  ), h = useSelector(c, (d) => d.matches("generating")), l = useSelector(c, (d) => d.matches("generated")), m = useSelector(c, (d) => d.matches({ generated: "activating" })), g = useSelector(c, (d) => d.matches({ generated: "activated" })), a = useSelector(c, (d) => d.context.error), s = useSelector(c, (d) => d.context.imageUrl || "");
  return {
    generateQrCode: () => wr(c),
    isGenerating: h,
    qrCodeDataUrl: s,
    isGenerated: l,
    activateMfa: (d) => kr(c, d),
    isActivating: m,
    isActivated: g,
    isError: i,
    error: a
  };
};
var xe = () => {
  const e = U();
  return e ? jwtDecode(e) : null;
};
var Se = (e) => {
  const t = p(), c = (E) => {
    e.send({
      type: "ADD",
      file: E.file,
      bucketId: E.bucketId || d
    });
  }, i = (E) => B(
    {
      url: t.storage.url,
      accessToken: t.auth.getAccessToken(),
      adminSecret: t.adminSecret,
      ...E
    },
    e
  ), h = () => {
    e.send("CANCEL");
  }, l = () => {
    e.send("DESTROY");
  }, m = useSelector(e, (E) => E.matches("uploading")), g = useSelector(e, (E) => E.matches("uploaded")), a = useSelector(e, (E) => E.matches("error")), s = useSelector(e, (E) => E.context.error || null), o = useSelector(e, (E) => E.context.progress), r = useSelector(e, (E) => E.context.id), d = useSelector(e, (E) => E.context.bucketId), u = useSelector(e, (E) => {
    var S;
    return (S = E.context.file) == null ? void 0 : S.name;
  });
  return {
    add: c,
    upload: i,
    cancel: h,
    destroy: l,
    isUploaded: g,
    isUploading: m,
    isError: a,
    error: s,
    progress: o,
    id: r,
    bucketId: d,
    name: u
  };
};
var Ke = () => {
  const e = useInterpret(N);
  return Se(e);
};
var L = () => {
  const e = xe();
  return (e == null ? void 0 : e["https://hasura.io/jwt/claims"]) || null;
};
var Ve = (e) => {
  const t = L();
  return (t == null ? void 0 : t[e.startsWith("x-hasura-") ? e : `x-hasura-${e}`]) || null;
};
var De = () => {
  const e = p(), [t, c] = (0, import_react6.useState)([]), i = useInterpret(X, {}, (u) => {
    u.event.type === "UPLOAD_ERROR" ? c(u.context.files.filter((E) => {
      var S;
      return (S = E.getSnapshot()) == null ? void 0 : S.context.error;
    })) : (u.matches("uploaded") || u.event.type === "CLEAR") && t.length > 0 && c([]);
  }), h = (u) => {
    i.send({ type: "ADD", ...u });
  }, l = (u) => V(
    {
      url: e.storage.url,
      accessToken: e.auth.getAccessToken(),
      adminSecret: e.adminSecret,
      ...u
    },
    i
  ), m = () => {
    i.send("CANCEL");
  }, g = () => {
    i.send("CLEAR");
  }, a = useSelector(i, (u) => u.matches("uploading")), s = useSelector(i, (u) => u.matches("uploaded")), o = useSelector(i, (u) => u.matches("error")), r = useSelector(i, (u) => u.context.progress), d = useSelector(i, (u) => u.context.files);
  return {
    upload: l,
    add: h,
    clear: g,
    cancel: m,
    progress: r,
    isUploaded: s,
    isUploading: a,
    files: d,
    isError: o,
    errors: t
  };
};
var Fe2 = (e) => {
  const [t, c] = (0, import_react6.useState)(true), i = U();
  (0, import_react6.useEffect)(() => {
    c(false);
  }, []);
  const h = (0, import_react6.useContext)(I);
  return new Proxy({}, {
    get(l, m) {
      let g = `${h.auth.client.backendUrl}/signin/provider/${m}`;
      const a = e != null && e.connect ? { connect: i } : {};
      return j(
        g,
        y(t ? void 0 : h.auth.client.clientUrl, {
          ...e,
          ...a
        })
      );
    }
  });
};
var _e = (e) => {
  const t = p(), c = (0, import_react6.useMemo)(() => Ye(t.auth.client), [t]), i = useInterpret(c), h = useSelector(i, (s) => s.matches("requesting")), l = useSelector(i, (s) => s.context.error), m = useSelector(i, (s) => s.matches("idle.error")), g = useSelector(i, (s) => s.matches("idle.success"));
  return { resetPassword: (s, o = e) => ze(i, s, o), isLoading: h, isSent: g, isError: m, error: l };
};
var qe2 = (e) => {
  const t = p(), c = (0, import_react6.useMemo)(() => He(t.auth.client), [t]), i = useInterpret(c), h = useSelector(i, (s) => s.matches({ idle: "error" })), l = useSelector(i, (s) => s.matches({ idle: "success" })), m = useSelector(i, (s) => s.context.error), g = useSelector(i, (s) => s.matches("requesting"));
  return { sendEmail: (s, o = e) => Qe(i, s, o), isLoading: g, isSent: l, isError: h, error: m };
};
var He2 = () => {
  const e = f(), t = () => Xe(e), c = useSelector(
    e,
    (a) => a.context.errors.authentication || null,
    (a, s) => (a == null ? void 0 : a.error) === (s == null ? void 0 : s.error)
  ), i = useSelector(
    e,
    (a) => a.matches({ authentication: { authenticating: "anonymous" } })
  ), h = useSelector(
    e,
    (a) => a.matches({
      authentication: "signedIn"
    })
  ), l = useSelector(
    e,
    (a) => a.matches({ authentication: { signedOut: "failed" } })
  ), m = useSelector(
    e,
    (a) => a.context.user,
    (a, s) => (a == null ? void 0 : a.id) === (s == null ? void 0 : s.id)
  );
  return { accessToken: useSelector(e, (a) => a.context.accessToken.value), error: c, isError: l, isLoading: i, isSuccess: h, signInAnonymous: t, user: m };
};
var Qe2 = () => {
  const e = f(), t = (u, E) => Ze(e, u, E), c = (u) => rr(e, u), i = useSelector(
    e,
    (u) => u.context.user,
    (u, E) => (u == null ? void 0 : u.id) === (E == null ? void 0 : E.id)
  ), h = useSelector(e, (u) => u.context.accessToken.value), l = useSelector(e, (u) => u.context.refreshToken.value), m = useSelector(
    e,
    (u) => u.context.errors.authentication || null,
    (u, E) => (u == null ? void 0 : u.error) === (E == null ? void 0 : E.error)
  ), g = useSelector(
    e,
    (u) => u.matches({
      authentication: "signedIn"
    })
  ), a = useSelector(
    e,
    (u) => u.matches({ authentication: { authenticating: "password" } }),
    (u, E) => u === E
  ), s = useSelector(
    e,
    (u) => u.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (u, E) => u === E
  ), o = useSelector(
    e,
    (u) => u.matches({ authentication: { signedOut: "needsMfa" } }),
    (u, E) => u === E
  ), r = useSelector(
    e,
    (u) => u.matches({ authentication: { signedOut: "failed" } }),
    (u, E) => u === E
  ), d = useSelector(e, (u) => u.context.mfa);
  return {
    accessToken: h,
    refreshToken: l,
    error: m,
    isError: r,
    isLoading: a,
    isSuccess: g,
    needsEmailVerification: s,
    needsMfaOtp: o,
    mfa: d,
    sendMfaOtp: c,
    signInEmailPassword: t,
    user: i
  };
};
function $e2(e) {
  const t = f(), c = (g, a = e) => Z(t, g, a), i = useSelector(
    t,
    (g) => g.context.errors.registration || null,
    (g, a) => (g == null ? void 0 : g.error) === (a == null ? void 0 : a.error)
  ), h = useSelector(t, (g) => g.matches("registration.passwordlessEmail")), l = useSelector(
    t,
    (g) => g.matches("registration.incomplete.needsEmailVerification")
  ), m = useSelector(t, (g) => g.matches("registration.incomplete.failed"));
  return { signInEmailPasswordless: c, isLoading: h, isSuccess: l, isError: m, error: i };
}
var je = () => {
  const e = f(), t = (o) => Je(e, o), c = useSelector(
    e,
    (o) => o.context.user,
    (o, r) => (o == null ? void 0 : o.id) === (r == null ? void 0 : r.id)
  ), i = useSelector(e, (o) => o.context.accessToken.value), h = useSelector(e, (o) => o.context.refreshToken.value), l = useSelector(
    e,
    (o) => o.context.errors.authentication || null,
    (o, r) => (o == null ? void 0 : o.error) === (r == null ? void 0 : r.error)
  ), m = useSelector(
    e,
    (o) => o.matches({
      authentication: "signedIn"
    })
  ), g = useSelector(
    e,
    (o) => o.matches({ authentication: { authenticating: "securityKeyEmail" } }),
    (o, r) => o === r
  ), a = useSelector(
    e,
    (o) => o.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (o, r) => o === r
  ), s = useSelector(
    e,
    (o) => o.matches({ authentication: { signedOut: "failed" } }),
    (o, r) => o === r
  );
  return {
    accessToken: i,
    refreshToken: h,
    error: l,
    isError: s,
    isLoading: g,
    isSuccess: m,
    needsEmailVerification: a,
    signInEmailSecurityKey: t,
    user: c
  };
};
var Pe = () => {
  const e = f();
  return useSelector(
    e,
    (t) => t.context.user,
    (t, c) => (t && JSON.stringify(t)) === (c && JSON.stringify(c))
  );
};
var Ge = () => {
  const e = Pe(), t = p(), c = L(), i = e ? (c == null ? void 0 : c["x-hasura-auth-elevated"]) === (e == null ? void 0 : e.id) : false, [h, l] = (0, import_react6.useState)(!!i), m = (g) => er(t.auth.client, g);
  return (0, import_react6.useEffect)(() => {
    l(!!i);
  }, [i]), {
    elevated: h,
    elevateEmailSecurityKey: m
  };
};
var Je2 = () => {
  const e = f(), t = (s) => nr(e, s), c = useSelector(
    e,
    (s) => s.context.user,
    (s, o) => (s == null ? void 0 : s.id) === (o == null ? void 0 : o.id)
  ), i = useSelector(e, (s) => s.context.accessToken.value), h = useSelector(e, (s) => s.context.refreshToken.value), l = useSelector(
    e,
    (s) => s.context.errors.authentication || null,
    (s, o) => (s == null ? void 0 : s.error) === (o == null ? void 0 : o.error)
  ), m = useSelector(e, (s) => s.matches({ authentication: "signedIn" })), g = useSelector(
    e,
    (s) => s.matches({ authentication: { authenticating: "password" } }),
    (s, o) => s === o
  ), a = useSelector(
    e,
    (s) => s.matches({ authentication: { signedOut: "failed" } }),
    (s, o) => s === o
  );
  return {
    accessToken: i,
    refreshToken: h,
    error: l,
    isError: a,
    isLoading: g,
    isSuccess: m,
    signInPAT: t,
    user: c
  };
};
function Ye2(e) {
  const t = f(), [c, i] = (0, import_react6.useState)(""), h = (r, d = e) => (i(r), J(t, r, d)), l = async (...r) => {
    if (r.length === 2) {
      const [u, E] = r;
      return tr(t, u, E);
    }
    const [d] = r;
    return tr(t, c, d);
  }, m = useSelector(
    t,
    (r) => r.context.errors.registration || null,
    (r, d) => (r == null ? void 0 : r.error) === (d == null ? void 0 : d.error)
  ), g = useSelector(
    t,
    (r) => r.matches("registration.passwordlessSms") || r.matches("registration.passwordlessSmsOtp")
  ), a = useSelector(t, (r) => r.matches("authentication.signedIn")), s = useSelector(
    t,
    (r) => r.matches("registration.incomplete.needsOtp")
  ), o = useSelector(t, (r) => r.matches("registration.incomplete.failed"));
  return { signInSmsPasswordless: h, sendOtp: l, isLoading: g, isSuccess: a, needsOtp: s, isError: o, error: m };
}
var We2 = (e = false) => {
  const t = f(), c = (l) => sr(t, typeof l == "boolean" ? l : e), i = useSelector(
    t,
    (l) => l.matches({ authentication: { signedOut: "success" } }),
    (l, m) => l === m
  ), h = useSelector(
    t,
    (l) => l.context.errors.signout || null,
    (l, m) => (l == null ? void 0 : l.error) === (m == null ? void 0 : m.error)
  );
  return { signOut: c, isSuccess: i, error: h };
};
var ze2 = (e) => {
  const t = f(), c = useSelector(t, (r) => !!r.context.errors.registration), i = useSelector(
    t,
    (r) => r.context.errors.registration || null,
    (r, d) => (r == null ? void 0 : r.error) === (d == null ? void 0 : d.error)
  ), h = useSelector(t, (r) => r.matches("registration.emailPassword")), l = useSelector(
    t,
    (r) => r.matches("registration.incomplete.needsEmailVerification")
  ), m = useSelector(
    t,
    (r) => r.matches({
      authentication: "signedIn",
      registration: "complete"
    })
  ), g = (r, d, u = e, E) => ee(t, r, d, u, E), a = useSelector(
    t,
    (r) => r.context.user,
    (r, d) => (r == null ? void 0 : r.id) === (d == null ? void 0 : d.id)
  ), s = useSelector(t, (r) => r.context.accessToken.value), o = useSelector(t, (r) => r.context.refreshToken.value);
  return {
    accessToken: s,
    refreshToken: o,
    error: i,
    isError: c,
    isLoading: h,
    isSuccess: m,
    needsEmailVerification: l,
    signUpEmailPassword: g,
    user: a
  };
};
var Be2 = (e) => {
  const t = f(), c = useSelector(t, (r) => !!r.context.errors.registration), i = useSelector(
    t,
    (r) => r.context.errors.registration || null,
    (r, d) => (r == null ? void 0 : r.error) === (d == null ? void 0 : d.error)
  ), h = useSelector(t, (r) => r.matches("registration.securityKey")), l = useSelector(
    t,
    (r) => r.matches("registration.incomplete.needsEmailVerification")
  ), m = useSelector(
    t,
    (r) => r.matches({
      authentication: "signedIn",
      registration: "complete"
    })
  ), g = (r, d = e) => ir(t, r, d), a = useSelector(
    t,
    (r) => r.context.user,
    (r, d) => (r == null ? void 0 : r.id) === (d == null ? void 0 : d.id)
  ), s = useSelector(t, (r) => r.context.accessToken.value), o = useSelector(t, (r) => r.context.refreshToken.value);
  return {
    accessToken: s,
    refreshToken: o,
    error: i,
    isError: c,
    isLoading: h,
    isSuccess: m,
    needsEmailVerification: l,
    signUpEmailSecurityKey: g,
    user: a
  };
};
var Xe2 = () => {
  const e = f();
  return useSelector(
    e,
    (t) => {
      var c;
      return (c = t.context.user) == null ? void 0 : c.avatarUrl;
    },
    (t, c) => t === c
  );
};
var Ze2 = () => {
  const e = f();
  return useSelector(
    e,
    (t) => {
      var c;
      return (c = t.context.user) == null ? void 0 : c.defaultRole;
    },
    (t, c) => t === c
  );
};
var be = () => {
  const e = f();
  return useSelector(
    e,
    (t) => {
      var c;
      return (c = t.context.user) == null ? void 0 : c.displayName;
    },
    (t, c) => t === c
  );
};
var et = () => {
  const e = f();
  return useSelector(
    e,
    (t) => {
      var c;
      return (c = t.context.user) == null ? void 0 : c.email;
    },
    (t, c) => t === c
  );
};
var tt = () => {
  const e = f();
  return useSelector(
    e,
    (t) => {
      var c;
      return (c = t.context.user) == null ? void 0 : c.id;
    },
    (t, c) => t === c
  );
};
var st = () => {
  const e = f();
  return useSelector(
    e,
    (t) => {
      var c;
      return (c = t.context.user) == null ? void 0 : c.isAnonymous;
    },
    (t, c) => t === c
  );
};
var nt = () => {
  const e = f();
  return useSelector(
    e,
    (t) => {
      var c;
      return (c = t.context.user) == null ? void 0 : c.locale;
    },
    (t, c) => t === c
  );
};
var ot = () => {
  const e = f();
  return useSelector(e, (t) => {
    var c;
    return t.matches("authentication.signedIn") ? ((c = t.context.user) == null ? void 0 : c.roles) || [] : [];
  });
};
function rt(e) {
  const t = f(), c = (s, o = e) => or(t, s, o), i = async (s, o) => ar(t, s, o), h = useSelector(
    t,
    (s) => s.context.errors.registration || null,
    (s, o) => (s == null ? void 0 : s.error) === (o == null ? void 0 : o.error)
  ), l = useSelector(
    t,
    (s) => s.matches("registration.signInEmailOTP") || s.matches("registration.verifyEmailOTP")
  ), m = useSelector(t, (s) => s.matches("authentication.signedIn")), g = useSelector(
    t,
    (s) => s.matches("registration.incomplete.needsOtp")
  ), a = useSelector(t, (s) => s.matches("registration.incomplete.failed"));
  return { signInEmailOTP: c, verifyEmailOTP: i, isLoading: l, isSuccess: m, isError: a, error: h, needsOtp: g };
}
var ct = () => {
  const e = f(), t = (s, o, r) => cr(e, {
    provider: s,
    idToken: o,
    nonce: r
  }), c = useSelector(
    e,
    (s) => s.context.user,
    (s, o) => (s == null ? void 0 : s.id) === (o == null ? void 0 : o.id)
  ), i = useSelector(e, (s) => s.context.accessToken.value), h = useSelector(e, (s) => s.context.refreshToken.value), l = useSelector(
    e,
    (s) => s.context.errors.authentication || null,
    (s, o) => (s == null ? void 0 : s.error) === (o == null ? void 0 : o.error)
  ), m = useSelector(e, (s) => s.matches({ authentication: "signedIn" })), g = useSelector(
    e,
    (s) => s.matches({ authentication: { authenticating: "idToken" } }),
    (s, o) => s === o
  ), a = useSelector(
    e,
    (s) => s.matches({ authentication: { signedOut: "failed" } }),
    (s, o) => s === o
  );
  return {
    accessToken: i,
    refreshToken: h,
    error: l,
    isError: a,
    isLoading: g,
    isSuccess: m,
    signInIdToken: t,
    user: c
  };
};
var it = () => {
  const e = p(), [t, c] = (0, import_react6.useState)(null), i = !t, h = !!t, [l, m] = (0, import_react6.useState)(false);
  return { linkIdToken: async ({
    provider: a,
    idToken: s,
    nonce: o
  }) => {
    m(true);
    const r = await ur(e.auth.client, {
      provider: a,
      idToken: s,
      ...o && { nonce: o }
    }), { error: d } = r;
    return d && c(d), m(false), r;
  }, isLoading: l, isSuccess: i, isError: h, error: t };
};
var at = () => {
  const e = f(), t = () => lr(e), c = useSelector(
    e,
    (o) => o.context.user,
    (o, r) => (o == null ? void 0 : o.id) === (r == null ? void 0 : r.id)
  ), i = useSelector(e, (o) => o.context.accessToken.value), h = useSelector(e, (o) => o.context.refreshToken.value), l = useSelector(
    e,
    (o) => o.context.errors.authentication || null,
    (o, r) => (o == null ? void 0 : o.error) === (r == null ? void 0 : r.error)
  ), m = useSelector(
    e,
    (o) => o.matches({
      authentication: "signedIn"
    })
  ), g = useSelector(
    e,
    (o) => o.matches({ authentication: { authenticating: "securityKeyEmail" } }),
    (o, r) => o === r
  ), a = useSelector(
    e,
    (o) => o.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (o, r) => o === r
  ), s = useSelector(
    e,
    (o) => o.matches({ authentication: { signedOut: "failed" } }),
    (o, r) => o === r
  );
  return {
    accessToken: i,
    refreshToken: h,
    error: l,
    isError: s,
    isLoading: g,
    isSuccess: m,
    needsEmailVerification: a,
    signInSecurityKey: t,
    user: c
  };
};

export {
  pe,
  Oe,
  I,
  ve,
  we,
  f,
  A,
  Ae,
  Ue,
  U,
  p,
  Le,
  Ce,
  Me,
  Ne,
  Re,
  xe,
  Se,
  Ke,
  L,
  Ve,
  De,
  Fe2 as Fe,
  _e,
  qe2 as qe,
  He2 as He,
  Qe2 as Qe,
  $e2 as $e,
  je,
  Pe,
  Ge,
  Je2 as Je,
  Ye2 as Ye,
  We2 as We,
  ze2 as ze,
  Be2 as Be,
  Xe2 as Xe,
  Ze2 as Ze,
  be,
  et,
  tt,
  st,
  nt,
  ot,
  rt,
  ct,
  it,
  at
};
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=chunk-LEHRCBHR.js.map
