{"version":3,"file":"index.cjs.js","sources":["../src/ws.ts","../src/index.ts"],"sourcesContent":["// * See https://github.com/enisdenjo/graphql-ws#graceful-restart\nimport { Client, ClientOptions, createClient } from 'graphql-ws'\n\nexport interface RestartableClient extends Client {\n  restart(): void\n  isOpen(): boolean\n}\n\nexport function createRestartableClient(options: ClientOptions): RestartableClient {\n  let restartRequested = false\n  let restart = () => {\n    restartRequested = true\n  }\n\n  let connectionOpen = false\n  let socket: WebSocket\n  let timedOut: NodeJS.Timeout\n\n  const client = createClient({\n    ...options,\n    on: {\n      ...options.on,\n      error: (error) => {\n        console.error(error)\n        options.on?.error?.(error)\n\n        restart()\n      },\n      ping: (received) => {\n        if (!received /* sent */) {\n          timedOut = setTimeout(() => {\n            // a close event `4499: Terminated` is issued to the current WebSocket and an\n            // artificial `{ code: 4499, reason: 'Terminated', wasClean: false }` close-event-like\n            // object is immediately emitted without waiting for the one coming from `WebSocket.onclose`\n            //\n            // calling terminate is not considered fatal and a connection retry will occur as expected\n            //\n            // see: https://github.com/enisdenjo/graphql-ws/discussions/290\n            client.terminate()\n            restart()\n          }, 5_000)\n        }\n      },\n      pong: (received) => {\n        if (received) {\n          clearTimeout(timedOut)\n        }\n      },\n      opened: (originalSocket) => {\n        socket = originalSocket as WebSocket\n        options.on?.opened?.(socket)\n        connectionOpen = true\n\n        restart = () => {\n          if (socket.readyState === WebSocket.OPEN) {\n            // if the socket is still open for the restart, do the restart\n            socket.close(4205, 'Client Restart')\n          } else {\n            // otherwise the socket might've closed, indicate that you want\n            // a restart on the next opened event\n            restartRequested = true\n          }\n        }\n\n        // just in case you were eager to restart\n        if (restartRequested) {\n          restartRequested = false\n          restart()\n        }\n      },\n      closed: (event) => {\n        options?.on?.closed?.(event)\n        connectionOpen = false\n      }\n    }\n  })\n\n  return {\n    ...client,\n    restart: () => restart(),\n    isOpen: () => connectionOpen\n  }\n}\n","import {\n  ApolloClient,\n  ApolloLink,\n  createHttpLink,\n  from,\n  InMemoryCache,\n  RequestHandler,\n  split,\n  WatchQueryFetchPolicy\n} from '@apollo/client/core'\nimport { setContext } from '@apollo/client/link/context'\nimport { GraphQLWsLink } from '@apollo/client/link/subscriptions'\nimport { getMainDefinition } from '@apollo/client/utilities'\nimport { AuthContext, NhostClient } from '@nhost/nhost-js'\n\nimport { createRestartableClient } from './ws'\nconst isBrowser = typeof window !== 'undefined'\n\nexport type NhostApolloClientOptions = {\n  nhost?: NhostClient\n  graphqlUrl?: string\n  headers?: any\n  publicRole?: string\n  fetchPolicy?: WatchQueryFetchPolicy\n  connectToDevTools?: boolean\n  cache?: InMemoryCache\n  /**\n   * @deprecated Please use `generateLinks` instead.\n   */\n  onError?: RequestHandler\n  /**\n   * @deprecated Please use `generateLinks` instead.\n   */\n  link?: ApolloLink\n  generateLinks?: (links: (ApolloLink | RequestHandler)[]) => (ApolloLink | RequestHandler)[]\n}\n\nexport const createApolloClient = ({\n  nhost,\n  graphqlUrl,\n  headers = {},\n  publicRole = 'public',\n  fetchPolicy,\n  cache = new InMemoryCache(),\n  connectToDevTools = isBrowser && process.env.NODE_ENV === 'development',\n  onError,\n  link: customLink,\n  generateLinks\n}: NhostApolloClientOptions) => {\n  const backendUrl = graphqlUrl || nhost?.graphql.httpUrl\n\n  if (!backendUrl) {\n    throw Error(\"Can't initialize the Apollo Client: no backend Url has been provided\")\n  }\n\n  const uri = backendUrl\n  const interpreter = nhost?.auth.client.interpreter\n\n  let accessToken: AuthContext['accessToken'] | null = null\n\n  const isTokenValid = () =>\n    !!accessToken?.value && !!accessToken?.expiresAt && accessToken?.expiresAt > new Date()\n\n  const isTokenValidOrNull = () => !accessToken || isTokenValid()\n\n  const awaitValidTokenOrNull = () => {\n    if (isTokenValidOrNull()) {\n      return\n    }\n\n    return new Promise((resolve) => {\n      // doing this as an interval to avoid race conditions.\n      const interval = setInterval(() => {\n        if (isTokenValidOrNull()) {\n          clearInterval(interval)\n          resolve(true)\n        }\n      }, 100)\n    })\n  }\n\n  const getAuthHeaders = async () => {\n    // wait for valid access token\n    await awaitValidTokenOrNull()\n\n    // add headers\n    const resHeaders = {\n      ...headers,\n      'Sec-WebSocket-Protocol': 'graphql-ws'\n    }\n\n    // add auth headers if signed in\n    // or add 'public' role if not signed in\n    if (accessToken) {\n      resHeaders.authorization = `Bearer ${accessToken.value}`\n    } else {\n      // ? Not sure it changes anything for Hasura\n      resHeaders.role = publicRole\n    }\n\n    return resHeaders\n  }\n\n  const wsClient = isBrowser\n    ? createRestartableClient({\n        url: uri.startsWith('https') ? uri.replace(/^https/, 'wss') : uri.replace(/^http/, 'ws'),\n        shouldRetry: () => true,\n        retryAttempts: 100,\n        retryWait: async (retries) => {\n          // start with 1 second delay\n          const baseDelay = 1000\n\n          // max 3 seconds of jitter\n          const maxJitter = 3000\n\n          // exponential backoff with jitter\n          return new Promise((resolve) =>\n            setTimeout(\n              resolve,\n              baseDelay * Math.pow(2, retries) + Math.floor(Math.random() * maxJitter)\n            )\n          )\n        },\n        connectionParams: async () => ({\n          headers: {\n            ...headers,\n            ...(await getAuthHeaders())\n          }\n        })\n      })\n    : null\n\n  const wsLink = wsClient ? new GraphQLWsLink(wsClient) : null\n\n  const httpLink = setContext(async (_, { headers }) => {\n    return {\n      headers: {\n        ...headers,\n        ...(await getAuthHeaders())\n      }\n    }\n  }).concat(createHttpLink({ uri }))\n\n  const splitLink = wsLink\n    ? split(\n        ({ query }) => {\n          const mainDefinition = getMainDefinition(query)\n\n          const { kind } = mainDefinition\n          let operation\n          if ('operation' in mainDefinition) {\n            operation = mainDefinition.operation\n          }\n\n          return kind === 'OperationDefinition' && operation === 'subscription'\n        },\n        wsLink,\n        httpLink\n      )\n    : httpLink\n\n  const links = []\n\n  if (onError) {\n    links.push(onError)\n  }\n\n  if (customLink) {\n    links.push(customLink)\n  }\n\n  links.push(splitLink)\n\n  const link = from(generateLinks ? generateLinks(links) : links)\n\n  const client = new ApolloClient({\n    cache: cache || new InMemoryCache(),\n    ssrMode: !isBrowser,\n    defaultOptions: {\n      watchQuery: {\n        fetchPolicy\n      }\n    },\n    connectToDevTools,\n    link\n  })\n\n  interpreter?.onTransition(async (state, event) => {\n    if (['SIGNOUT', 'SIGNED_IN', 'TOKEN_CHANGED'].includes(event.type)) {\n      if (\n        event.type === 'SIGNOUT' ||\n        (event.type === 'TOKEN_CHANGED' && state.context.accessToken.value === null)\n      ) {\n        accessToken = null\n\n        try {\n          await client.resetStore()\n        } catch (error) {\n          console.error('Error resetting Apollo client cache')\n          console.error(error)\n        }\n\n        return\n      }\n\n      // update token\n      accessToken = state.context.accessToken\n\n      if (!isBrowser || !wsClient?.isOpen()) {\n        return\n      }\n\n      wsClient?.restart()\n    }\n  })\n\n  return client\n}\n"],"names":["createRestartableClient","options","restartRequested","restart","connectionOpen","socket","timedOut","client","createClient","error","_b","_a","received","originalSocket","event","isBrowser","createApolloClient","nhost","graphqlUrl","headers","publicRole","fetchPolicy","cache","InMemoryCache","connectToDevTools","onError","customLink","generateLinks","backendUrl","uri","interpreter","accessToken","isTokenValid","isTokenValidOrNull","awaitValidTokenOrNull","resolve","interval","getAuthHeaders","resHeaders","wsClient","retries","wsLink","GraphQLWsLink","httpLink","setContext","_","createHttpLink","splitLink","split","query","mainDefinition","getMainDefinition","kind","operation","links","link","from","ApolloClient","state"],"mappings":"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"}