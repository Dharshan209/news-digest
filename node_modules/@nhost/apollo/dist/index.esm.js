import { createHttpLink as g, split as G, from as M, ApolloClient as H, InMemoryCache as C } from "@apollo/client/core";
import { setContext as P } from "@apollo/client/link/context";
import { GraphQLWsLink as U } from "@apollo/client/link/subscriptions";
import { getMainDefinition as W } from "@apollo/client/utilities";
import { createClient as _ } from "graphql-ws";
function L(t) {
  let c = !1, l = () => {
    c = !0;
  }, p = !1, u, d;
  const m = _({
    ...t,
    on: {
      ...t.on,
      error: (n) => {
        var e, a;
        console.error(n), (a = (e = t.on) == null ? void 0 : e.error) == null || a.call(e, n), l();
      },
      ping: (n) => {
        n || (d = setTimeout(() => {
          m.terminate(), l();
        }, 5e3));
      },
      pong: (n) => {
        n && clearTimeout(d);
      },
      opened: (n) => {
        var e, a;
        u = n, (a = (e = t.on) == null ? void 0 : e.opened) == null || a.call(e, u), p = !0, l = () => {
          u.readyState === WebSocket.OPEN ? u.close(4205, "Client Restart") : c = !0;
        }, c && (c = !1, l());
      },
      closed: (n) => {
        var e, a;
        (a = (e = t == null ? void 0 : t.on) == null ? void 0 : e.closed) == null || a.call(e, n), p = !1;
      }
    }
  });
  return {
    ...m,
    restart: () => l(),
    isOpen: () => p
  };
}
const O = typeof window != "undefined", J = ({
  nhost: t,
  graphqlUrl: c,
  headers: l = {},
  publicRole: p = "public",
  fetchPolicy: u,
  cache: d = new C(),
  connectToDevTools: m = O && process.env.NODE_ENV === "development",
  onError: n,
  link: e,
  generateLinks: a
}) => {
  const k = c || (t == null ? void 0 : t.graphql.httpUrl);
  if (!k)
    throw Error("Can't initialize the Apollo Client: no backend Url has been provided");
  const h = k, N = t == null ? void 0 : t.auth.client.interpreter;
  let r = null;
  const S = () => !!(r != null && r.value) && !!(r != null && r.expiresAt) && (r == null ? void 0 : r.expiresAt) > /* @__PURE__ */ new Date(), b = () => !r || S(), T = () => {
    if (!b())
      return new Promise((i) => {
        const o = setInterval(() => {
          b() && (clearInterval(o), i(!0));
        }, 100);
      });
  }, A = async () => {
    await T();
    const i = {
      ...l,
      "Sec-WebSocket-Protocol": "graphql-ws"
    };
    return r ? i.authorization = `Bearer ${r.value}` : i.role = p, i;
  }, s = O ? L({
    url: h.startsWith("https") ? h.replace(/^https/, "wss") : h.replace(/^http/, "ws"),
    shouldRetry: () => !0,
    retryAttempts: 100,
    retryWait: async (i) => new Promise(
      (y) => setTimeout(
        y,
        1e3 * Math.pow(2, i) + Math.floor(Math.random() * 3e3)
      )
    ),
    connectionParams: async () => ({
      headers: {
        ...l,
        ...await A()
      }
    })
  }) : null, D = s ? new U(s) : null, E = P(async (i, { headers: o }) => ({
    headers: {
      ...o,
      ...await A()
    }
  })).concat(g({ uri: h })), v = D ? G(
    ({ query: i }) => {
      const o = W(i), { kind: w } = o;
      let y;
      return "operation" in o && (y = o.operation), w === "OperationDefinition" && y === "subscription";
    },
    D,
    E
  ) : E, f = [];
  n && f.push(n), e && f.push(e), f.push(v);
  const I = M(a ? a(f) : f), x = new H({
    cache: d || new C(),
    ssrMode: !O,
    defaultOptions: {
      watchQuery: {
        fetchPolicy: u
      }
    },
    connectToDevTools: m,
    link: I
  });
  return N == null || N.onTransition(async (i, o) => {
    if (["SIGNOUT", "SIGNED_IN", "TOKEN_CHANGED"].includes(o.type)) {
      if (o.type === "SIGNOUT" || o.type === "TOKEN_CHANGED" && i.context.accessToken.value === null) {
        r = null;
        try {
          await x.resetStore();
        } catch (w) {
          console.error("Error resetting Apollo client cache"), console.error(w);
        }
        return;
      }
      if (r = i.context.accessToken, !O || !(s != null && s.isOpen()))
        return;
      s == null || s.restart();
    }
  }), x;
};
export {
  J as createApolloClient
};
//# sourceMappingURL=index.esm.js.map
