import { NhostClient as C, addSecurityKeyPromise as M, createChangeEmailMachine as N, changeEmailPromise as R, createChangePasswordMachine as K, changePasswordPromise as V, createEnableMfaMachine as D, generateQrCodePromise as F, activateMfaPromise as _, createFileUploadMachine as q, uploadFilePromise as H, createMultipleFilesUploadMachine as Q, uploadMultipleFilesPromise as $, encodeQueryParameters as j, rewriteRedirectTo as G, createResetPasswordMachine as J, resetPasswordPromise as Y, createSendVerificationEmailMachine as W, sendVerificationEmailPromise as z, signInAnonymousPromise as B, signInEmailPasswordPromise as X, signInMfaTotpPromise as Z, signInEmailPasswordlessPromise as b, signInEmailSecurityKeyPromise as ee, elevateEmailSecurityKeyPromise as te, signInPATPromise as se, signInSmsPasswordlessPromise as ne, signInSmsPasswordlessOtpPromise as k, signOutPromise as oe, signUpEmailPasswordPromise as re, signUpEmailSecurityKeyPromise as ce, signInEmailOTPPromise as ie, verifyEmailOTPPromise as ae, signInIdTokenPromise as ue, linkIdTokenPromise as le, signInSecurityKeyPromise as de } from "@nhost/nhost-js";
import { NHOST_REFRESH_TOKEN_KEY as dt } from "@nhost/nhost-js";
import he, { createContext as me, useRef as ge, useEffect as T, useContext as y, createElement as O, Fragment as w, useState as v, useMemo as P, useCallback as Ee } from "react";
import { useInterpret as x, useSelector as n } from "@xstate/react";
import { jwtDecode as fe } from "jwt-decode";
const pe = C;
class Oe extends pe {
  constructor(t) {
    super({ ...t, start: !1 });
  }
}
const I = me({}), ve = ({
  nhost: e,
  initial: t,
  ...c
}) => {
  const i = x(e.auth.client.machine, { devTools: e.devTools });
  e.auth.client.start({ interpreter: i, initialSession: t, devTools: e.devTools });
  const h = ge(!0);
  return T(() => {
    h.current ? h.current = !1 : t && i.send("SESSION_UPDATE", { data: { session: t } });
  }, [t, i]), /* @__PURE__ */ he.createElement(I.Provider, { value: e }, c.children);
}, we = ve, f = () => {
  var c;
  const t = (c = y(I).auth) == null ? void 0 : c.client.interpreter;
  if (!t)
    throw Error("Could not find the Nhost auth client. Did you wrap your app in <NhostProvider />?");
  return t;
}, A = () => {
  const e = f();
  return n(
    e,
    (t) => ({
      isAuthenticated: t.matches({ authentication: "signedIn" }),
      isLoading: t.hasTag("loading"),
      error: t.context.errors.authentication || null,
      isError: t.matches({ authentication: { signedOut: "failed" } }),
      connectionAttempts: t.context.importTokenAttempts
    }),
    (t, c) => t.isAuthenticated === c.isAuthenticated && t.isLoading === c.isLoading && t.connectionAttempts === c.connectionAttempts
  );
};
function Ae({ children: e }) {
  const { isAuthenticated: t } = A();
  return t ? O(w, null, e) : null;
}
function Ue({ children: e }) {
  const { isAuthenticated: t } = A();
  return t ? null : O(w, null, e);
}
const U = () => {
  const e = f();
  return n(e, (t) => t.context.accessToken.value);
}, p = () => y(I), Le = () => {
  const e = p(), [t, c] = v(null), i = !t, h = !!t, [l, m] = v(!1);
  return { add: async (a) => {
    m(!0);
    const s = await M(e.auth.client, a), { error: o } = s;
    return o && c(o), m(!1), s;
  }, isLoading: l, isSuccess: i, isError: h, error: t };
}, Ce = () => {
  const e = f(), [t, c] = v(
    !!e.status && e.getSnapshot().matches({ authentication: "signedIn" })
  );
  return T(() => e.subscribe((h) => {
    const l = h.matches({ authentication: "signedIn" });
    c(l);
  }).unsubscribe, [e]), t;
};
function Me(e) {
  const t = p(), c = P(() => N(t.auth.client), [t]), i = x(c), h = n(i, (s) => s.matches("requesting")), l = n(i, (s) => s.context.error), m = n(i, (s) => s.matches("idle.error")), g = n(i, (s) => s.matches("idle.success"));
  return { changeEmail: Ee(
    async (s, o = e) => R(i, s, o),
    [i, e]
  ), isLoading: h, needsEmailVerification: g, isError: m, error: l };
}
const Ne = () => {
  const e = p(), t = P(() => K(e.auth.client), [e]), c = x(t), i = n(c, (a) => a.matches({ idle: "error" })), h = n(c, (a) => a.matches({ idle: "success" })), l = n(c, (a) => a.context.error), m = n(c, (a) => a.matches("requesting"));
  return { changePassword: (a) => V(c, a), isLoading: m, isSuccess: h, isError: i, error: l };
}, Re = () => {
  const e = p(), t = P(() => D(e.auth.client), [e]), c = x(t), i = n(
    c,
    (d) => d.matches({ idle: "error" }) || d.matches({ generated: { idle: "error" } })
  ), h = n(c, (d) => d.matches("generating")), l = n(c, (d) => d.matches("generated")), m = n(c, (d) => d.matches({ generated: "activating" })), g = n(c, (d) => d.matches({ generated: "activated" })), a = n(c, (d) => d.context.error), s = n(c, (d) => d.context.imageUrl || "");
  return {
    generateQrCode: () => F(c),
    isGenerating: h,
    qrCodeDataUrl: s,
    isGenerated: l,
    activateMfa: (d) => _(c, d),
    isActivating: m,
    isActivated: g,
    isError: i,
    error: a
  };
}, xe = () => {
  const e = U();
  return e ? fe(e) : null;
}, Se = (e) => {
  const t = p(), c = (E) => {
    e.send({
      type: "ADD",
      file: E.file,
      bucketId: E.bucketId || d
    });
  }, i = (E) => H(
    {
      url: t.storage.url,
      accessToken: t.auth.getAccessToken(),
      adminSecret: t.adminSecret,
      ...E
    },
    e
  ), h = () => {
    e.send("CANCEL");
  }, l = () => {
    e.send("DESTROY");
  }, m = n(e, (E) => E.matches("uploading")), g = n(e, (E) => E.matches("uploaded")), a = n(e, (E) => E.matches("error")), s = n(e, (E) => E.context.error || null), o = n(e, (E) => E.context.progress), r = n(e, (E) => E.context.id), d = n(e, (E) => E.context.bucketId), u = n(e, (E) => {
    var S;
    return (S = E.context.file) == null ? void 0 : S.name;
  });
  return {
    add: c,
    upload: i,
    cancel: h,
    destroy: l,
    isUploaded: g,
    isUploading: m,
    isError: a,
    error: s,
    progress: o,
    id: r,
    bucketId: d,
    name: u
  };
}, Ke = () => {
  const e = x(q);
  return Se(e);
}, L = () => {
  const e = xe();
  return (e == null ? void 0 : e["https://hasura.io/jwt/claims"]) || null;
}, Ve = (e) => {
  const t = L();
  return (t == null ? void 0 : t[e.startsWith("x-hasura-") ? e : `x-hasura-${e}`]) || null;
}, De = () => {
  const e = p(), [t, c] = v([]), i = x(Q, {}, (u) => {
    u.event.type === "UPLOAD_ERROR" ? c(u.context.files.filter((E) => {
      var S;
      return (S = E.getSnapshot()) == null ? void 0 : S.context.error;
    })) : (u.matches("uploaded") || u.event.type === "CLEAR") && t.length > 0 && c([]);
  }), h = (u) => {
    i.send({ type: "ADD", ...u });
  }, l = (u) => $(
    {
      url: e.storage.url,
      accessToken: e.auth.getAccessToken(),
      adminSecret: e.adminSecret,
      ...u
    },
    i
  ), m = () => {
    i.send("CANCEL");
  }, g = () => {
    i.send("CLEAR");
  }, a = n(i, (u) => u.matches("uploading")), s = n(i, (u) => u.matches("uploaded")), o = n(i, (u) => u.matches("error")), r = n(i, (u) => u.context.progress), d = n(i, (u) => u.context.files);
  return {
    upload: l,
    add: h,
    clear: g,
    cancel: m,
    progress: r,
    isUploaded: s,
    isUploading: a,
    files: d,
    isError: o,
    errors: t
  };
}, Fe = (e) => {
  const [t, c] = v(!0), i = U();
  T(() => {
    c(!1);
  }, []);
  const h = y(I);
  return new Proxy({}, {
    get(l, m) {
      let g = `${h.auth.client.backendUrl}/signin/provider/${m}`;
      const a = e != null && e.connect ? { connect: i } : {};
      return j(
        g,
        G(t ? void 0 : h.auth.client.clientUrl, {
          ...e,
          ...a
        })
      );
    }
  });
}, _e = (e) => {
  const t = p(), c = P(() => J(t.auth.client), [t]), i = x(c), h = n(i, (s) => s.matches("requesting")), l = n(i, (s) => s.context.error), m = n(i, (s) => s.matches("idle.error")), g = n(i, (s) => s.matches("idle.success"));
  return { resetPassword: (s, o = e) => Y(i, s, o), isLoading: h, isSent: g, isError: m, error: l };
}, qe = (e) => {
  const t = p(), c = P(() => W(t.auth.client), [t]), i = x(c), h = n(i, (s) => s.matches({ idle: "error" })), l = n(i, (s) => s.matches({ idle: "success" })), m = n(i, (s) => s.context.error), g = n(i, (s) => s.matches("requesting"));
  return { sendEmail: (s, o = e) => z(i, s, o), isLoading: g, isSent: l, isError: h, error: m };
}, He = () => {
  const e = f(), t = () => B(e), c = n(
    e,
    (a) => a.context.errors.authentication || null,
    (a, s) => (a == null ? void 0 : a.error) === (s == null ? void 0 : s.error)
  ), i = n(
    e,
    (a) => a.matches({ authentication: { authenticating: "anonymous" } })
  ), h = n(
    e,
    (a) => a.matches({
      authentication: "signedIn"
    })
  ), l = n(
    e,
    (a) => a.matches({ authentication: { signedOut: "failed" } })
  ), m = n(
    e,
    (a) => a.context.user,
    (a, s) => (a == null ? void 0 : a.id) === (s == null ? void 0 : s.id)
  );
  return { accessToken: n(e, (a) => a.context.accessToken.value), error: c, isError: l, isLoading: i, isSuccess: h, signInAnonymous: t, user: m };
}, Qe = () => {
  const e = f(), t = (u, E) => X(e, u, E), c = (u) => Z(e, u), i = n(
    e,
    (u) => u.context.user,
    (u, E) => (u == null ? void 0 : u.id) === (E == null ? void 0 : E.id)
  ), h = n(e, (u) => u.context.accessToken.value), l = n(e, (u) => u.context.refreshToken.value), m = n(
    e,
    (u) => u.context.errors.authentication || null,
    (u, E) => (u == null ? void 0 : u.error) === (E == null ? void 0 : E.error)
  ), g = n(
    e,
    (u) => u.matches({
      authentication: "signedIn"
    })
  ), a = n(
    e,
    (u) => u.matches({ authentication: { authenticating: "password" } }),
    (u, E) => u === E
  ), s = n(
    e,
    (u) => u.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (u, E) => u === E
  ), o = n(
    e,
    (u) => u.matches({ authentication: { signedOut: "needsMfa" } }),
    (u, E) => u === E
  ), r = n(
    e,
    (u) => u.matches({ authentication: { signedOut: "failed" } }),
    (u, E) => u === E
  ), d = n(e, (u) => u.context.mfa);
  return {
    accessToken: h,
    refreshToken: l,
    error: m,
    isError: r,
    isLoading: a,
    isSuccess: g,
    needsEmailVerification: s,
    needsMfaOtp: o,
    mfa: d,
    sendMfaOtp: c,
    signInEmailPassword: t,
    user: i
  };
};
function $e(e) {
  const t = f(), c = (g, a = e) => b(t, g, a), i = n(
    t,
    (g) => g.context.errors.registration || null,
    (g, a) => (g == null ? void 0 : g.error) === (a == null ? void 0 : a.error)
  ), h = n(t, (g) => g.matches("registration.passwordlessEmail")), l = n(
    t,
    (g) => g.matches("registration.incomplete.needsEmailVerification")
  ), m = n(t, (g) => g.matches("registration.incomplete.failed"));
  return { signInEmailPasswordless: c, isLoading: h, isSuccess: l, isError: m, error: i };
}
const je = () => {
  const e = f(), t = (o) => ee(e, o), c = n(
    e,
    (o) => o.context.user,
    (o, r) => (o == null ? void 0 : o.id) === (r == null ? void 0 : r.id)
  ), i = n(e, (o) => o.context.accessToken.value), h = n(e, (o) => o.context.refreshToken.value), l = n(
    e,
    (o) => o.context.errors.authentication || null,
    (o, r) => (o == null ? void 0 : o.error) === (r == null ? void 0 : r.error)
  ), m = n(
    e,
    (o) => o.matches({
      authentication: "signedIn"
    })
  ), g = n(
    e,
    (o) => o.matches({ authentication: { authenticating: "securityKeyEmail" } }),
    (o, r) => o === r
  ), a = n(
    e,
    (o) => o.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (o, r) => o === r
  ), s = n(
    e,
    (o) => o.matches({ authentication: { signedOut: "failed" } }),
    (o, r) => o === r
  );
  return {
    accessToken: i,
    refreshToken: h,
    error: l,
    isError: s,
    isLoading: g,
    isSuccess: m,
    needsEmailVerification: a,
    signInEmailSecurityKey: t,
    user: c
  };
}, Pe = () => {
  const e = f();
  return n(
    e,
    (t) => t.context.user,
    (t, c) => (t && JSON.stringify(t)) === (c && JSON.stringify(c))
  );
}, Ge = () => {
  const e = Pe(), t = p(), c = L(), i = e ? (c == null ? void 0 : c["x-hasura-auth-elevated"]) === (e == null ? void 0 : e.id) : !1, [h, l] = v(!!i), m = (g) => te(t.auth.client, g);
  return T(() => {
    l(!!i);
  }, [i]), {
    elevated: h,
    elevateEmailSecurityKey: m
  };
}, Je = () => {
  const e = f(), t = (s) => se(e, s), c = n(
    e,
    (s) => s.context.user,
    (s, o) => (s == null ? void 0 : s.id) === (o == null ? void 0 : o.id)
  ), i = n(e, (s) => s.context.accessToken.value), h = n(e, (s) => s.context.refreshToken.value), l = n(
    e,
    (s) => s.context.errors.authentication || null,
    (s, o) => (s == null ? void 0 : s.error) === (o == null ? void 0 : o.error)
  ), m = n(e, (s) => s.matches({ authentication: "signedIn" })), g = n(
    e,
    (s) => s.matches({ authentication: { authenticating: "password" } }),
    (s, o) => s === o
  ), a = n(
    e,
    (s) => s.matches({ authentication: { signedOut: "failed" } }),
    (s, o) => s === o
  );
  return {
    accessToken: i,
    refreshToken: h,
    error: l,
    isError: a,
    isLoading: g,
    isSuccess: m,
    signInPAT: t,
    user: c
  };
};
function Ye(e) {
  const t = f(), [c, i] = v(""), h = (r, d = e) => (i(r), ne(t, r, d)), l = async (...r) => {
    if (r.length === 2) {
      const [u, E] = r;
      return k(t, u, E);
    }
    const [d] = r;
    return k(t, c, d);
  }, m = n(
    t,
    (r) => r.context.errors.registration || null,
    (r, d) => (r == null ? void 0 : r.error) === (d == null ? void 0 : d.error)
  ), g = n(
    t,
    (r) => r.matches("registration.passwordlessSms") || r.matches("registration.passwordlessSmsOtp")
  ), a = n(t, (r) => r.matches("authentication.signedIn")), s = n(
    t,
    (r) => r.matches("registration.incomplete.needsOtp")
  ), o = n(t, (r) => r.matches("registration.incomplete.failed"));
  return { signInSmsPasswordless: h, sendOtp: l, isLoading: g, isSuccess: a, needsOtp: s, isError: o, error: m };
}
const We = (e = !1) => {
  const t = f(), c = (l) => oe(t, typeof l == "boolean" ? l : e), i = n(
    t,
    (l) => l.matches({ authentication: { signedOut: "success" } }),
    (l, m) => l === m
  ), h = n(
    t,
    (l) => l.context.errors.signout || null,
    (l, m) => (l == null ? void 0 : l.error) === (m == null ? void 0 : m.error)
  );
  return { signOut: c, isSuccess: i, error: h };
}, ze = (e) => {
  const t = f(), c = n(t, (r) => !!r.context.errors.registration), i = n(
    t,
    (r) => r.context.errors.registration || null,
    (r, d) => (r == null ? void 0 : r.error) === (d == null ? void 0 : d.error)
  ), h = n(t, (r) => r.matches("registration.emailPassword")), l = n(
    t,
    (r) => r.matches("registration.incomplete.needsEmailVerification")
  ), m = n(
    t,
    (r) => r.matches({
      authentication: "signedIn",
      registration: "complete"
    })
  ), g = (r, d, u = e, E) => re(t, r, d, u, E), a = n(
    t,
    (r) => r.context.user,
    (r, d) => (r == null ? void 0 : r.id) === (d == null ? void 0 : d.id)
  ), s = n(t, (r) => r.context.accessToken.value), o = n(t, (r) => r.context.refreshToken.value);
  return {
    accessToken: s,
    refreshToken: o,
    error: i,
    isError: c,
    isLoading: h,
    isSuccess: m,
    needsEmailVerification: l,
    signUpEmailPassword: g,
    user: a
  };
}, Be = (e) => {
  const t = f(), c = n(t, (r) => !!r.context.errors.registration), i = n(
    t,
    (r) => r.context.errors.registration || null,
    (r, d) => (r == null ? void 0 : r.error) === (d == null ? void 0 : d.error)
  ), h = n(t, (r) => r.matches("registration.securityKey")), l = n(
    t,
    (r) => r.matches("registration.incomplete.needsEmailVerification")
  ), m = n(
    t,
    (r) => r.matches({
      authentication: "signedIn",
      registration: "complete"
    })
  ), g = (r, d = e) => ce(t, r, d), a = n(
    t,
    (r) => r.context.user,
    (r, d) => (r == null ? void 0 : r.id) === (d == null ? void 0 : d.id)
  ), s = n(t, (r) => r.context.accessToken.value), o = n(t, (r) => r.context.refreshToken.value);
  return {
    accessToken: s,
    refreshToken: o,
    error: i,
    isError: c,
    isLoading: h,
    isSuccess: m,
    needsEmailVerification: l,
    signUpEmailSecurityKey: g,
    user: a
  };
}, Xe = () => {
  const e = f();
  return n(
    e,
    (t) => {
      var c;
      return (c = t.context.user) == null ? void 0 : c.avatarUrl;
    },
    (t, c) => t === c
  );
}, Ze = () => {
  const e = f();
  return n(
    e,
    (t) => {
      var c;
      return (c = t.context.user) == null ? void 0 : c.defaultRole;
    },
    (t, c) => t === c
  );
}, be = () => {
  const e = f();
  return n(
    e,
    (t) => {
      var c;
      return (c = t.context.user) == null ? void 0 : c.displayName;
    },
    (t, c) => t === c
  );
}, et = () => {
  const e = f();
  return n(
    e,
    (t) => {
      var c;
      return (c = t.context.user) == null ? void 0 : c.email;
    },
    (t, c) => t === c
  );
}, tt = () => {
  const e = f();
  return n(
    e,
    (t) => {
      var c;
      return (c = t.context.user) == null ? void 0 : c.id;
    },
    (t, c) => t === c
  );
}, st = () => {
  const e = f();
  return n(
    e,
    (t) => {
      var c;
      return (c = t.context.user) == null ? void 0 : c.isAnonymous;
    },
    (t, c) => t === c
  );
}, nt = () => {
  const e = f();
  return n(
    e,
    (t) => {
      var c;
      return (c = t.context.user) == null ? void 0 : c.locale;
    },
    (t, c) => t === c
  );
}, ot = () => {
  const e = f();
  return n(e, (t) => {
    var c;
    return t.matches("authentication.signedIn") ? ((c = t.context.user) == null ? void 0 : c.roles) || [] : [];
  });
};
function rt(e) {
  const t = f(), c = (s, o = e) => ie(t, s, o), i = async (s, o) => ae(t, s, o), h = n(
    t,
    (s) => s.context.errors.registration || null,
    (s, o) => (s == null ? void 0 : s.error) === (o == null ? void 0 : o.error)
  ), l = n(
    t,
    (s) => s.matches("registration.signInEmailOTP") || s.matches("registration.verifyEmailOTP")
  ), m = n(t, (s) => s.matches("authentication.signedIn")), g = n(
    t,
    (s) => s.matches("registration.incomplete.needsOtp")
  ), a = n(t, (s) => s.matches("registration.incomplete.failed"));
  return { signInEmailOTP: c, verifyEmailOTP: i, isLoading: l, isSuccess: m, isError: a, error: h, needsOtp: g };
}
const ct = () => {
  const e = f(), t = (s, o, r) => ue(e, {
    provider: s,
    idToken: o,
    nonce: r
  }), c = n(
    e,
    (s) => s.context.user,
    (s, o) => (s == null ? void 0 : s.id) === (o == null ? void 0 : o.id)
  ), i = n(e, (s) => s.context.accessToken.value), h = n(e, (s) => s.context.refreshToken.value), l = n(
    e,
    (s) => s.context.errors.authentication || null,
    (s, o) => (s == null ? void 0 : s.error) === (o == null ? void 0 : o.error)
  ), m = n(e, (s) => s.matches({ authentication: "signedIn" })), g = n(
    e,
    (s) => s.matches({ authentication: { authenticating: "idToken" } }),
    (s, o) => s === o
  ), a = n(
    e,
    (s) => s.matches({ authentication: { signedOut: "failed" } }),
    (s, o) => s === o
  );
  return {
    accessToken: i,
    refreshToken: h,
    error: l,
    isError: a,
    isLoading: g,
    isSuccess: m,
    signInIdToken: t,
    user: c
  };
}, it = () => {
  const e = p(), [t, c] = v(null), i = !t, h = !!t, [l, m] = v(!1);
  return { linkIdToken: async ({
    provider: a,
    idToken: s,
    nonce: o
  }) => {
    m(!0);
    const r = await le(e.auth.client, {
      provider: a,
      idToken: s,
      ...o && { nonce: o }
    }), { error: d } = r;
    return d && c(d), m(!1), r;
  }, isLoading: l, isSuccess: i, isError: h, error: t };
}, at = () => {
  const e = f(), t = () => de(e), c = n(
    e,
    (o) => o.context.user,
    (o, r) => (o == null ? void 0 : o.id) === (r == null ? void 0 : r.id)
  ), i = n(e, (o) => o.context.accessToken.value), h = n(e, (o) => o.context.refreshToken.value), l = n(
    e,
    (o) => o.context.errors.authentication || null,
    (o, r) => (o == null ? void 0 : o.error) === (r == null ? void 0 : r.error)
  ), m = n(
    e,
    (o) => o.matches({
      authentication: "signedIn"
    })
  ), g = n(
    e,
    (o) => o.matches({ authentication: { authenticating: "securityKeyEmail" } }),
    (o, r) => o === r
  ), a = n(
    e,
    (o) => o.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (o, r) => o === r
  ), s = n(
    e,
    (o) => o.matches({ authentication: { signedOut: "failed" } }),
    (o, r) => o === r
  );
  return {
    accessToken: i,
    refreshToken: h,
    error: l,
    isError: s,
    isLoading: g,
    isSuccess: m,
    needsEmailVerification: a,
    signInSecurityKey: t,
    user: c
  };
};
export {
  dt as NHOST_REFRESH_TOKEN_KEY,
  Oe as NhostClient,
  ve as NhostProvider,
  I as NhostReactContext,
  we as NhostReactProvider,
  Ae as SignedIn,
  Ue as SignedOut,
  pe as VanillaNhostClient,
  U as useAccessToken,
  Le as useAddSecurityKey,
  f as useAuthInterpreter,
  Ce as useAuthenticated,
  A as useAuthenticationStatus,
  Me as useChangeEmail,
  Ne as useChangePassword,
  Re as useConfigMfa,
  xe as useDecodedAccessToken,
  Ge as useElevateSecurityKeyEmail,
  Ke as useFileUpload,
  Se as useFileUploadItem,
  Ve as useHasuraClaim,
  L as useHasuraClaims,
  it as useLinkIdToken,
  De as useMultipleFilesUpload,
  p as useNhostClient,
  Fe as useProviderLink,
  _e as useResetPassword,
  qe as useSendVerificationEmail,
  He as useSignInAnonymous,
  rt as useSignInEmailOTP,
  Qe as useSignInEmailPassword,
  $e as useSignInEmailPasswordless,
  je as useSignInEmailSecurityKey,
  ct as useSignInIdToken,
  Je as useSignInPAT,
  at as useSignInSecurityKey,
  Ye as useSignInSmsPasswordless,
  We as useSignOut,
  ze as useSignUpEmailPassword,
  Be as useSignUpEmailSecurityKeyEmail,
  Xe as useUserAvatarUrl,
  Pe as useUserData,
  Ze as useUserDefaultRole,
  be as useUserDisplayName,
  et as useUserEmail,
  tt as useUserId,
  st as useUserIsAnonymous,
  nt as useUserLocale,
  ot as useUserRoles
};
//# sourceMappingURL=index.esm.js.map
