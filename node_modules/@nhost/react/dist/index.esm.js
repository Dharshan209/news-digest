import { NhostClient as O, addSecurityKeyPromise as C, createChangeEmailMachine as L, changeEmailPromise as M, createChangePasswordMachine as N, changePasswordPromise as R, createEnableMfaMachine as V, generateQrCodePromise as D, activateMfaPromise as K, createFileUploadMachine as F, uploadFilePromise as _, createMultipleFilesUploadMachine as q, uploadMultipleFilesPromise as H, encodeQueryParameters as Q, rewriteRedirectTo as $, createResetPasswordMachine as j, resetPasswordPromise as G, createSendVerificationEmailMachine as J, sendVerificationEmailPromise as Y, signInAnonymousPromise as W, signInEmailPasswordPromise as z, signInMfaTotpPromise as B, signInEmailPasswordlessPromise as X, signInEmailSecurityKeyPromise as Z, signInPATPromise as b, signInSmsPasswordlessPromise as ee, signInSmsPasswordlessOtpPromise as k, signOutPromise as te, signUpEmailPasswordPromise as se, signUpEmailSecurityKeyPromise as ne } from "@nhost/nhost-js";
import { NHOST_REFRESH_TOKEN_KEY as et } from "@nhost/nhost-js";
import oe, { createContext as re, useRef as ce, useEffect as T, useContext as y, createElement as w, Fragment as A, useState as v, useMemo as P, useCallback as ie } from "react";
import { useInterpret as f, useSelector as s } from "@xstate/react";
import ae from "jwt-decode";
const ue = O;
class ve extends ue {
  constructor(e) {
    super({ ...e, start: !1 });
  }
}
const I = re({}), le = ({
  nhost: t,
  initial: e,
  ...n
}) => {
  const a = f(t.auth.client.machine, { devTools: t.devTools });
  t.auth.client.start({ interpreter: a, initialSession: e, devTools: t.devTools });
  const g = ce(!0);
  return T(() => {
    g.current ? g.current = !1 : e && a.send("SESSION_UPDATE", { data: { session: e } });
  }, [e, a]), /* @__PURE__ */ oe.createElement(I.Provider, { value: t }, n.children);
}, Se = le, E = () => {
  var n;
  const e = (n = y(I).auth) == null ? void 0 : n.client.interpreter;
  if (!e)
    throw Error("Could not find the Nhost auth client. Did you wrap your app in <NhostProvider />?");
  return e;
}, U = () => {
  const t = E();
  return s(
    t,
    (e) => ({
      isAuthenticated: e.matches({ authentication: "signedIn" }),
      isLoading: e.hasTag("loading"),
      error: e.context.errors.authentication || null,
      isError: e.matches({ authentication: { signedOut: "failed" } }),
      connectionAttempts: e.context.importTokenAttempts
    }),
    (e, n) => e.isAuthenticated === n.isAuthenticated && e.isLoading === n.isLoading && e.connectionAttempts === n.connectionAttempts
  );
};
function Pe({ children: t }) {
  const { isAuthenticated: e } = U();
  return e ? w(A, null, t) : null;
}
function Ie({ children: t }) {
  const { isAuthenticated: e } = U();
  return e ? null : w(A, null, t);
}
const de = () => {
  const t = E();
  return s(t, (e) => e.context.accessToken.value);
}, x = () => y(I), Te = () => {
  const t = x(), [e, n] = v(null), a = !e, g = !!e, [d, p] = v(!1);
  return { add: async (u) => {
    p(!0);
    const r = await C(t.auth.client, u), { error: c } = r;
    return c && n(c), p(!1), r;
  }, isLoading: d, isSuccess: a, isError: g, error: e };
}, ye = () => {
  const t = E(), [e, n] = v(
    !!t.status && t.getSnapshot().matches({ authentication: "signedIn" })
  );
  return T(() => t.subscribe((g) => {
    const d = g.matches({ authentication: "signedIn" });
    n(d);
  }).unsubscribe, [t]), e;
};
function ke(t) {
  const e = x(), n = P(() => L(e.auth.client), [e]), a = f(n), g = s(a, (r) => r.matches("requesting")), d = s(a, (r) => r.context.error), p = s(a, (r) => r.matches("idle.error")), m = s(a, (r) => r.matches("idle.success"));
  return { changeEmail: ie(
    async (r, c = t) => M(a, r, c),
    [a, t]
  ), isLoading: g, needsEmailVerification: m, isError: p, error: d };
}
const we = () => {
  const t = x(), e = P(() => N(t.auth.client), [t]), n = f(e), a = s(n, (u) => u.matches({ idle: "error" })), g = s(n, (u) => u.matches({ idle: "success" })), d = s(n, (u) => u.context.error), p = s(n, (u) => u.matches("requesting"));
  return { changePassword: (u) => R(n, u), isLoading: p, isSuccess: g, isError: a, error: d };
}, Ae = () => {
  const t = x(), e = P(() => V(t.auth.client), [t]), n = f(e), a = s(
    n,
    (l) => l.matches({ idle: "error" }) || l.matches({ generated: { idle: "error" } })
  ), g = s(n, (l) => l.matches("generating")), d = s(n, (l) => l.matches("generated")), p = s(n, (l) => l.matches({ generated: "activating" })), m = s(n, (l) => l.matches({ generated: "activated" })), u = s(n, (l) => l.context.error), r = s(n, (l) => l.context.imageUrl || "");
  return {
    generateQrCode: () => D(n),
    isGenerating: g,
    qrCodeDataUrl: r,
    isGenerated: d,
    activateMfa: (l) => K(n, l),
    isActivating: p,
    isActivated: m,
    isError: a,
    error: u
  };
}, he = () => {
  const t = de();
  return t ? ae(t) : null;
}, me = (t) => {
  const e = x(), n = (h) => {
    t.send({
      type: "ADD",
      file: h.file,
      bucketId: h.bucketId || l
    });
  }, a = (h) => _(
    {
      url: e.storage.url,
      accessToken: e.auth.getAccessToken(),
      adminSecret: e.adminSecret,
      ...h
    },
    t
  ), g = () => {
    t.send("CANCEL");
  }, d = () => {
    t.send("DESTROY");
  }, p = s(t, (h) => h.matches("uploading")), m = s(t, (h) => h.matches("uploaded")), u = s(t, (h) => h.matches("error")), r = s(t, (h) => h.context.error || null), c = s(t, (h) => h.context.progress), o = s(t, (h) => h.context.id), l = s(t, (h) => h.context.bucketId), i = s(t, (h) => {
    var S;
    return (S = h.context.file) == null ? void 0 : S.name;
  });
  return {
    add: n,
    upload: a,
    cancel: g,
    destroy: d,
    isUploaded: m,
    isUploading: p,
    isError: u,
    error: r,
    progress: c,
    id: o,
    bucketId: l,
    name: i
  };
}, Ue = () => {
  const t = f(F);
  return me(t);
}, ge = () => {
  const t = he();
  return (t == null ? void 0 : t["https://hasura.io/jwt/claims"]) || null;
}, Oe = (t) => {
  const e = ge();
  return (e == null ? void 0 : e[t.startsWith("x-hasura-") ? t : `x-hasura-${t}`]) || null;
}, Ce = () => {
  const t = x(), [e, n] = v([]), a = f(q, {}, (i) => {
    i.event.type === "UPLOAD_ERROR" ? n(i.context.files.filter((h) => {
      var S;
      return (S = h.getSnapshot()) == null ? void 0 : S.context.error;
    })) : (i.matches("uploaded") || i.event.type === "CLEAR") && e.length > 0 && n([]);
  }), g = (i) => {
    a.send({ type: "ADD", ...i });
  }, d = (i) => H(
    {
      url: t.storage.url,
      accessToken: t.auth.getAccessToken(),
      adminSecret: t.adminSecret,
      ...i
    },
    a
  ), p = () => {
    a.send("CANCEL");
  }, m = () => {
    a.send("CLEAR");
  }, u = s(a, (i) => i.matches("uploading")), r = s(a, (i) => i.matches("uploaded")), c = s(a, (i) => i.matches("error")), o = s(a, (i) => i.context.progress), l = s(a, (i) => i.context.files);
  return {
    upload: d,
    add: g,
    clear: m,
    cancel: p,
    progress: o,
    isUploaded: r,
    isUploading: u,
    files: l,
    isError: c,
    errors: e
  };
}, Le = (t) => {
  const [e, n] = v(!0);
  T(() => {
    n(!1);
  }, []);
  const a = y(I);
  return new Proxy({}, {
    get(g, d) {
      return Q(
        `${a.auth.client.backendUrl}/signin/provider/${d}`,
        $(e ? void 0 : a.auth.client.clientUrl, t)
      );
    }
  });
}, Me = (t) => {
  const e = x(), n = P(() => j(e.auth.client), [e]), a = f(n), g = s(a, (r) => r.matches("requesting")), d = s(a, (r) => r.context.error), p = s(a, (r) => r.matches("idle.error")), m = s(a, (r) => r.matches("idle.success"));
  return { resetPassword: (r, c = t) => G(a, r, c), isLoading: g, isSent: m, isError: p, error: d };
}, Ne = (t) => {
  const e = x(), n = P(() => J(e.auth.client), [e]), a = f(n), g = s(a, (r) => r.matches({ idle: "error" })), d = s(a, (r) => r.matches({ idle: "success" })), p = s(a, (r) => r.context.error), m = s(a, (r) => r.matches("requesting"));
  return { sendEmail: (r, c = t) => Y(a, r, c), isLoading: m, isSent: d, isError: g, error: p };
}, Re = () => {
  const t = E(), e = () => W(t), n = s(
    t,
    (u) => u.context.errors.authentication || null,
    (u, r) => (u == null ? void 0 : u.error) === (r == null ? void 0 : r.error)
  ), a = s(
    t,
    (u) => u.matches({ authentication: { authenticating: "anonymous" } })
  ), g = s(
    t,
    (u) => u.matches({
      authentication: "signedIn"
    })
  ), d = s(
    t,
    (u) => u.matches({ authentication: { signedOut: "failed" } })
  ), p = s(
    t,
    (u) => u.context.user,
    (u, r) => (u == null ? void 0 : u.id) === (r == null ? void 0 : r.id)
  );
  return { accessToken: s(t, (u) => u.context.accessToken.value), error: n, isError: d, isLoading: a, isSuccess: g, signInAnonymous: e, user: p };
}, Ve = () => {
  const t = E(), e = (i, h) => z(t, i, h), n = (i) => B(t, i), a = s(
    t,
    (i) => i.context.user,
    (i, h) => (i == null ? void 0 : i.id) === (h == null ? void 0 : h.id)
  ), g = s(t, (i) => i.context.accessToken.value), d = s(t, (i) => i.context.refreshToken.value), p = s(
    t,
    (i) => i.context.errors.authentication || null,
    (i, h) => (i == null ? void 0 : i.error) === (h == null ? void 0 : h.error)
  ), m = s(
    t,
    (i) => i.matches({
      authentication: "signedIn"
    })
  ), u = s(
    t,
    (i) => i.matches({ authentication: { authenticating: "password" } }),
    (i, h) => i === h
  ), r = s(
    t,
    (i) => i.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (i, h) => i === h
  ), c = s(
    t,
    (i) => i.matches({ authentication: { signedOut: "needsMfa" } }),
    (i, h) => i === h
  ), o = s(
    t,
    (i) => i.matches({ authentication: { signedOut: "failed" } }),
    (i, h) => i === h
  ), l = s(t, (i) => i.context.mfa);
  return {
    accessToken: g,
    refreshToken: d,
    error: p,
    isError: o,
    isLoading: u,
    isSuccess: m,
    needsEmailVerification: r,
    needsMfaOtp: c,
    mfa: l,
    sendMfaOtp: n,
    signInEmailPassword: e,
    user: a
  };
};
function De(t) {
  const e = E(), n = (m, u = t) => X(e, m, u), a = s(
    e,
    (m) => m.context.errors.registration || null,
    (m, u) => (m == null ? void 0 : m.error) === (u == null ? void 0 : u.error)
  ), g = s(e, (m) => m.matches("registration.passwordlessEmail")), d = s(
    e,
    (m) => m.matches("registration.incomplete.needsEmailVerification")
  ), p = s(e, (m) => m.matches("registration.incomplete.failed"));
  return { signInEmailPasswordless: n, isLoading: g, isSuccess: d, isError: p, error: a };
}
const Ke = () => {
  const t = E(), e = (c) => Z(t, c), n = s(
    t,
    (c) => c.context.user,
    (c, o) => (c == null ? void 0 : c.id) === (o == null ? void 0 : o.id)
  ), a = s(t, (c) => c.context.accessToken.value), g = s(t, (c) => c.context.refreshToken.value), d = s(
    t,
    (c) => c.context.errors.authentication || null,
    (c, o) => (c == null ? void 0 : c.error) === (o == null ? void 0 : o.error)
  ), p = s(
    t,
    (c) => c.matches({
      authentication: "signedIn"
    })
  ), m = s(
    t,
    (c) => c.matches({ authentication: { authenticating: "securityKeyEmail" } }),
    (c, o) => c === o
  ), u = s(
    t,
    (c) => c.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (c, o) => c === o
  ), r = s(
    t,
    (c) => c.matches({ authentication: { signedOut: "failed" } }),
    (c, o) => c === o
  );
  return {
    accessToken: a,
    refreshToken: g,
    error: d,
    isError: r,
    isLoading: m,
    isSuccess: p,
    needsEmailVerification: u,
    signInEmailSecurityKey: e,
    user: n
  };
}, Fe = () => {
  const t = E(), e = (r) => b(t, r), n = s(
    t,
    (r) => r.context.user,
    (r, c) => (r == null ? void 0 : r.id) === (c == null ? void 0 : c.id)
  ), a = s(t, (r) => r.context.accessToken.value), g = s(t, (r) => r.context.refreshToken.value), d = s(
    t,
    (r) => r.context.errors.authentication || null,
    (r, c) => (r == null ? void 0 : r.error) === (c == null ? void 0 : c.error)
  ), p = s(t, (r) => r.matches({ authentication: "signedIn" })), m = s(
    t,
    (r) => r.matches({ authentication: { authenticating: "password" } }),
    (r, c) => r === c
  ), u = s(
    t,
    (r) => r.matches({ authentication: { signedOut: "failed" } }),
    (r, c) => r === c
  );
  return {
    accessToken: a,
    refreshToken: g,
    error: d,
    isError: u,
    isLoading: m,
    isSuccess: p,
    signInPAT: e,
    user: n
  };
};
function _e(t) {
  const e = E(), [n, a] = v(""), g = (o, l = t) => (a(o), ee(e, o, l)), d = async (...o) => {
    if (o.length === 2) {
      const [i, h] = o;
      return k(e, i, h);
    }
    const [l] = o;
    return k(e, n, l);
  }, p = s(
    e,
    (o) => o.context.errors.registration || null,
    (o, l) => (o == null ? void 0 : o.error) === (l == null ? void 0 : l.error)
  ), m = s(
    e,
    (o) => o.matches("registration.passwordlessSms") || o.matches("registration.passwordlessSmsOtp")
  ), u = s(e, (o) => o.matches("authentication.signedIn")), r = s(
    e,
    (o) => o.matches("registration.incomplete.needsOtp")
  ), c = s(e, (o) => o.matches("registration.incomplete.failed"));
  return { signInSmsPasswordless: g, sendOtp: d, isLoading: m, isSuccess: u, needsOtp: r, isError: c, error: p };
}
const qe = (t = !1) => {
  const e = E(), n = (d) => te(e, typeof d == "boolean" ? d : t), a = s(
    e,
    (d) => d.matches({ authentication: { signedOut: "success" } }),
    (d, p) => d === p
  ), g = s(
    e,
    (d) => d.context.errors.signout || null,
    (d, p) => (d == null ? void 0 : d.error) === (p == null ? void 0 : p.error)
  );
  return { signOut: n, isSuccess: a, error: g };
}, He = (t) => {
  const e = E(), n = s(e, (o) => !!o.context.errors.registration), a = s(
    e,
    (o) => o.context.errors.registration || null,
    (o, l) => (o == null ? void 0 : o.error) === (l == null ? void 0 : l.error)
  ), g = s(e, (o) => o.matches("registration.emailPassword")), d = s(
    e,
    (o) => o.matches("registration.incomplete.needsEmailVerification")
  ), p = s(
    e,
    (o) => o.matches({
      authentication: "signedIn",
      registration: "complete"
    })
  ), m = (o, l, i = t) => se(e, o, l, i), u = s(
    e,
    (o) => o.context.user,
    (o, l) => (o == null ? void 0 : o.id) === (l == null ? void 0 : l.id)
  ), r = s(e, (o) => o.context.accessToken.value), c = s(e, (o) => o.context.refreshToken.value);
  return {
    accessToken: r,
    refreshToken: c,
    error: a,
    isError: n,
    isLoading: g,
    isSuccess: p,
    needsEmailVerification: d,
    signUpEmailPassword: m,
    user: u
  };
}, Qe = (t) => {
  const e = E(), n = s(e, (o) => !!o.context.errors.registration), a = s(
    e,
    (o) => o.context.errors.registration || null,
    (o, l) => (o == null ? void 0 : o.error) === (l == null ? void 0 : l.error)
  ), g = s(e, (o) => o.matches("registration.securityKey")), d = s(
    e,
    (o) => o.matches("registration.incomplete.needsEmailVerification")
  ), p = s(
    e,
    (o) => o.matches({
      authentication: "signedIn",
      registration: "complete"
    })
  ), m = (o, l = t) => ne(e, o, l), u = s(
    e,
    (o) => o.context.user,
    (o, l) => (o == null ? void 0 : o.id) === (l == null ? void 0 : l.id)
  ), r = s(e, (o) => o.context.accessToken.value), c = s(e, (o) => o.context.refreshToken.value);
  return {
    accessToken: r,
    refreshToken: c,
    error: a,
    isError: n,
    isLoading: g,
    isSuccess: p,
    needsEmailVerification: d,
    signUpEmailSecurityKey: m,
    user: u
  };
}, $e = () => {
  const t = E();
  return s(
    t,
    (e) => {
      var n;
      return (n = e.context.user) == null ? void 0 : n.avatarUrl;
    },
    (e, n) => e === n
  );
}, je = () => {
  const t = E();
  return s(
    t,
    (e) => e.context.user,
    (e, n) => (e && JSON.stringify(e)) === (n && JSON.stringify(n))
  );
}, Ge = () => {
  const t = E();
  return s(
    t,
    (e) => {
      var n;
      return (n = e.context.user) == null ? void 0 : n.defaultRole;
    },
    (e, n) => e === n
  );
}, Je = () => {
  const t = E();
  return s(
    t,
    (e) => {
      var n;
      return (n = e.context.user) == null ? void 0 : n.displayName;
    },
    (e, n) => e === n
  );
}, Ye = () => {
  const t = E();
  return s(
    t,
    (e) => {
      var n;
      return (n = e.context.user) == null ? void 0 : n.email;
    },
    (e, n) => e === n
  );
}, We = () => {
  const t = E();
  return s(
    t,
    (e) => {
      var n;
      return (n = e.context.user) == null ? void 0 : n.id;
    },
    (e, n) => e === n
  );
}, ze = () => {
  const t = E();
  return s(
    t,
    (e) => {
      var n;
      return (n = e.context.user) == null ? void 0 : n.isAnonymous;
    },
    (e, n) => e === n
  );
}, Be = () => {
  const t = E();
  return s(
    t,
    (e) => {
      var n;
      return (n = e.context.user) == null ? void 0 : n.locale;
    },
    (e, n) => e === n
  );
}, Xe = () => {
  const t = E();
  return s(t, (e) => {
    var n;
    return e.matches("authentication.signedIn") ? ((n = e.context.user) == null ? void 0 : n.roles) || [] : [];
  });
};
export {
  et as NHOST_REFRESH_TOKEN_KEY,
  ve as NhostClient,
  le as NhostProvider,
  I as NhostReactContext,
  Se as NhostReactProvider,
  Pe as SignedIn,
  Ie as SignedOut,
  ue as VanillaNhostClient,
  de as useAccessToken,
  Te as useAddSecurityKey,
  E as useAuthInterpreter,
  ye as useAuthenticated,
  U as useAuthenticationStatus,
  ke as useChangeEmail,
  we as useChangePassword,
  Ae as useConfigMfa,
  he as useDecodedAccessToken,
  Ue as useFileUpload,
  me as useFileUploadItem,
  Oe as useHasuraClaim,
  ge as useHasuraClaims,
  Ce as useMultipleFilesUpload,
  x as useNhostClient,
  Le as useProviderLink,
  Me as useResetPassword,
  Ne as useSendVerificationEmail,
  Re as useSignInAnonymous,
  Ve as useSignInEmailPassword,
  De as useSignInEmailPasswordless,
  Ke as useSignInEmailSecurityKey,
  Fe as useSignInPAT,
  _e as useSignInSmsPasswordless,
  qe as useSignOut,
  He as useSignUpEmailPassword,
  Qe as useSignUpEmailSecurityKeyEmail,
  $e as useUserAvatarUrl,
  je as useUserData,
  Ge as useUserDefaultRole,
  Je as useUserDisplayName,
  Ye as useUserEmail,
  We as useUserId,
  ze as useUserIsAnonymous,
  Be as useUserLocale,
  Xe as useUserRoles
};
//# sourceMappingURL=index.esm.js.map
